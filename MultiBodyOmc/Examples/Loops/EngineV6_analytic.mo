within MultiBodyOmc.Examples.Loops;
model EngineV6_analytic
  "V6 engine with 6 cylinders, 6 planar loops, 1 degree-of-freedom and analytic handling of kinematic loops"

  import Cv = Modelica.SIunits.Conversions;
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Example;
  parameter Boolean animation=true "= true, if animation shall be enabled";
  output Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm
    engineSpeed_rpm=
         Modelica.SIunits.Conversions.to_rpm(load.w) "Engine speed";
  output Modelica.SIunits.Torque engineTorque = filter.u
    "Torque generated by engine";
  output Modelica.SIunits.Torque filteredEngineTorque = filter.y
    "Filtered torque generated by engine";

  inner MultiBodyOmc.World world(animateWorld=false,
      animateGravity =                                                              false)
    annotation (Placement(transformation(extent={{-80,-20},{-60,0}}, rotation=0)));
  Utilities.EngineV6_analytic engine(redeclare model Cylinder =
        MultiBodyOmc.Examples.Loops.Utilities.Cylinder_analytic_CAD)
    annotation (Placement(transformation(extent={{-40,0},{0,40}}, rotation=0)));
  Modelica.Mechanics.Rotational.Components.Inertia load(
                                             phi(
      start=0,
      fixed=true), w(
      start=10,
      fixed=true),
    stateSelect=StateSelect.always,
    J=1)                               annotation (Placement(transformation(
          extent={{40,10},{60,30}}, rotation=0)));
  Modelica.Mechanics.Rotational.Sources.QuadraticSpeedDependentTorque load2(
                                                 tau_nominal=-100, w_nominal=
        200,
    useSupport=false)
             annotation (Placement(transformation(extent={{90,10},{70,30}},
          rotation=0)));
  Rotational.Sensors.TorqueSensor torqueSensor
    annotation (Placement(transformation(extent={{12,10},{32,30}}, rotation=0)));
  Blocks.Continuous.CriticalDamping filter(
    n=2,
    initType=Modelica.Blocks.Types.Init.SteadyState,
    f=5) annotation (Placement(transformation(extent={{30,-20},{50,0}},
          rotation=0)));
equation

  connect(world.frame_b, engine.frame_a)
    annotation (Line(
      points={{-60,-10},{-20,-10},{-20,-0.2}},
      color={95,95,95},
      thickness=0.5));
  connect(load2.flange, load.flange_b)
    annotation (Line(points={{70,20},{60,20}}, color={0,0,0}));
  connect(torqueSensor.flange_a, engine.flange_b)
    annotation (Line(points={{12,20},{2,20}}, color={0,0,0}));
  connect(torqueSensor.flange_b, load.flange_a)
    annotation (Line(points={{32,20},{40,20}}, color={0,0,0}));
  connect(torqueSensor.tau, filter.u) annotation (Line(points={{14,9},{14,-10},
          {28,-10}}, color={0,0,127}));
  annotation (
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={2,2}), graphics),
    Documentation(info="<HTML>
<p>
This is a similar model as the example \"EngineV6\". However, the cylinders
have been built up with component MultiBodyOmc.Joints.Assemblies.JointRRR that
solves the non-linear system of equations in an aggregation of 3 revolution
joints <b>analytically</b> and only one body is used that holds the total
mass of the crank shaft:
</p>
<p align=\"center\">
<IMG SRC=\"../Images/MultiBody/Examples/Loops/EngineV6_CAD_small.png\">
</p>
<p>
This model is about 20 times faster as the EngineV6 example and <b>no</b> linear or
non-linear system of equations occur. In contrast, the \"EngineV6\" example
leads to 6 systems of nonlinear equations (every system has dimension = 5, with
Evaluate=false and dimension=1 with Evaluate=true) and a linear system of equations
of about 40. This shows the power of the analytic loop handling.
</p>

<p>
Simulate for 5 s, and plot the variables <b>engineSpeed_rpm</b>,
<b>engineTorque</b>, and <b>filteredEngineTorque</b>. Note, the result file has
a size of about 50 Mbyte (for 5000 output intervalls).
</p>
</HTML>
"));
end EngineV6_analytic;
